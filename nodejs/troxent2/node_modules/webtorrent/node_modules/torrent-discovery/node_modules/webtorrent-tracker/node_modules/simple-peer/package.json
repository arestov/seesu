{
  "name": "simple-peer",
  "description": "Simple one-to-one WebRTC video/voice and data channels",
  "version": "3.6.4",
  "author": {
    "name": "Feross Aboukhadijeh",
    "email": "feross@feross.org",
    "url": "http://feross.org/"
  },
  "bugs": {
    "url": "https://github.com/feross/simple-peer/issues"
  },
  "dependencies": {
    "debug": "^2.1.0",
    "extend.js": "0.0.1",
    "hat": "0.0.3",
    "inherits": "^2.0.1",
    "is-typedarray": "0.0.0",
    "once": "^1.3.1",
    "typedarray-to-buffer": "^1.0.3"
  },
  "homepage": "http://webtorrent.io",
  "keywords": [
    "webrtc",
    "p2p",
    "data channel",
    "data channels",
    "data",
    "video",
    "voice",
    "peer",
    "stream",
    "peer-to-peer",
    "data channel stream",
    "webrtc stream",
    "peer"
  ],
  "license": "MIT",
  "main": "index.js",
  "repository": {
    "type": "git",
    "url": "git://github.com/feross/simple-peer.git"
  },
  "scripts": {
    "test": "zuul -- test/*.js",
    "prepublish": "npm run build",
    "build": "browserify -s SimplePeer -r ./ | uglifyjs -c warnings=false -m > simplepeer.bundle.js"
  },
  "devDependencies": {
    "browserify": "^5.9.1",
    "concat-stream": "^1.4.6",
    "tape": "^2.13.4",
    "uglify-js": "^2.4.15",
    "zuul": "^1.11.1"
  },
  "testling": {
    "files": "test/*.js"
  },
  "readme": "# simple-peer [![travis](https://img.shields.io/travis/feross/simple-peer.svg?style=flat)](https://travis-ci.org/feross/simple-peer) [![npm](https://img.shields.io/npm/v/simple-peer.svg?style=flat)](https://npmjs.org/package/simple-peer) [![npm downloads](https://img.shields.io/npm/dm/simple-peer.svg?style=flat)](https://npmjs.org/package/simple-peer) [![gittip](https://img.shields.io/gittip/feross.svg?style=flat)](https://www.gittip.com/feross/)\n\n#### Simple WebRTC video/voice and data channels.\n\n[![Sauce Test Status](https://saucelabs.com/browser-matrix/feross-simple-peer.svg)](https://saucelabs.com/u/feross-simple-peer)\n\n## features\n\n- **super simple** API for working with [WebRTC](https://en.wikipedia.org/wiki/WebRTC)\n- supports **video/voice streams**\n- supports **data channel**\n  - text and binary data\n  - optionally, treat data channel as a node.js [duplex stream](http://nodejs.org/api/stream.html)\n- supports advanced options like:\n  - enable/disable [trickle ICE candidates](http://webrtchacks.com/trickle-ice/)\n  - manually set config and constraints options\n\nThis module works great in the browser with [browserify](http://browserify.org/).\n\n**Note:** If you're **NOT** using browserify, then use the included standalone file\n`simplepeer.bundle.js`. This exports a `SimplePeer` function on `window`.\n\n## install\n\n```\nnpm install simple-peer\n```\n\n## usage\n\nThese examples create two peers in the same page.\n\nIn a real-world application, the sender and receiver `Peer` instances would exist in separate browsers. A \"signaling server\" (usually implemented with websockets) would be used to exchange signaling data between the two browsers until a peer-to-peer connection is established.\n\n### data channels\n\n```js\nvar SimplePeer = require('simple-peer')\n\nvar peer1 = new SimplePeer({ initiator: true })\nvar peer2 = new SimplePeer()\n\npeer1.on('signal', function (data) {\n  // when peer1 has signaling data, give it to peer2\n  peer2.signal(data)\n})\n\npeer2.on('signal', function (data) {\n  // same as above, but in reverse\n  peer1.signal(data)\n})\n\npeer1.on('ready', function () {\n  // wait for 'ready' event before using the data channel\n  peer1.send('hey peer2, how is it going?')\n})\n\npeer2.on('message', function (data) {\n  // got a data channel message\n  console.log('got a message from peer1: ' + data)\n})\n```\n\n### video/voice\n\nVideo/voice is also super simple! In this example, peer1 sends video to peer2.\n\n```js\nvar SimplePeer = require('simple-peer')\n\n// get video/voice stream\nnavigator.getUserMedia({ video: true, audio: true }, gotMedia, function () {})\n\nfunction gotMedia (stream) {\n  var peer1 = new SimplePeer({ initiator: true, stream: stream })\n  var peer2 = new SimplePeer()\n\n  peer1.on('signal', function (data) {\n    peer2.signal(data)\n  })\n\n  peer2.on('signal', function (data) {\n    peer1.signal(data)\n  })\n\n  peer2.on('stream', function (stream) {\n    // got remote video stream, now let's show it in a video tag\n    var video = document.querySelector('video')\n    video.src = window.URL.createObjectURL(stream)\n    video.play()\n  })\n}\n```\n\nFor two-way video, simply pass a `stream` option into both `Peer` constructors. Simple!\n\n## real-world apps that use `simple-peer`\n\n- [Instant](https://instant.io) - Secure, anonymous, streaming file transfer\n- [WebTorrent](http://webtorrent.io) - Streaming torrent client in the browser\n- [PusherTC](http://pushertc.herokuapp.com) - Video chat with using Pusher. See [guide](http://blog.carbonfive.com/2014/10/16/webrtc-made-simple/).\n- [lxjs-chat](https://github.com/feross/lxjs-chat) - Omegle-like video chat site\n- *Your app here! - send a PR!*\n\n## api\n\n### `peer = new SimplePeer([opts])`\n\nCreate a new WebRTC peer connection.\n\nA \"data channel\" for text/binary communication is always established, because it's cheap and often useful. For video/voice communication, pass the `stream` option.\n\nIf `opts` is specified, then the default options (shown below) will be overridden.\n\n```\n{\n  initiator: false,\n  stream: false,\n  config: { iceServers: [ { url: 'stun:23.21.150.121' } ] },\n  constraints: {},\n  channelName: '<random string>',\n  trickle: true\n}\n```\n\nThe options do the following:\n\n- `initiator` - set to true if this is the initiating peer\n- `stream` - if video/voice is desired, pass stream returned from `getUserMedia`\n- `config` - custom webrtc configuration\n- `constraints` - custom webrtc video/voice constaints\n- `channelName` - custom webrtc data channel name\n- `trickle` - set to `false` to disable [trickle ICE](http://webrtchacks.com/trickle-ice/) and get a single 'signal' event (slower)\n\n### `peer.signal(data)`\n\nCall this method whenever the remote peer emits a `peer.on('signal')` event.\n\nThe `data` will be a `String` that encapsulates a webrtc offer, answer, or ice candidate. These messages help the peers to eventually establish a direct connection to each other. The contents of these strings are an implementation detail that can be ignored by the user of this module; simply pass the data from 'signal' events to the remote peer, call `peer.signal(data)`, and everything will just work.\n\n### `peer.send(data)`\n\nSend text/binary data to the remote peer. `data` can be any of several types: `String`, `Buffer` (see [buffer](https://github.com/feross/buffer)), TypedArrayView (Uint8Array, etc.), or ArrayBuffer.\n\nNote: this method should not be called until the `peer.on('ready')` event has fired.\n\n### `peer.destroy([onclose])`\n\nDestroy and cleanup this peer connection.\n\nIf the optional `onclose` parameter is passed, then it will be registered as a listener on the 'close' event.\n\n### `stream = peer.getDataStream()`\n\nReturns a duplex stream which reads/writes to the data channel.\n\nVery handy for treating the data channel just like any other node.js stream!\n\n\n## events\n\n\n### `peer.on('signal', function (data) {})`\n\nFired when the peer wants to send signaling data to the remote peer.\n\n**It is the responsibility of the application developer (that's you!) to get this data to the other peer.** This usually entails using a websocket signaling server. Then, simply call `peer.signal(data)` on the remote peer.\n\n### `peer.on('ready', function () {})`\n\nFired when the peer connection and data channel are ready to use.\n\n### `peer.on('message', function (data) {})`\n\nReceived a message from the remote peer (via the data channel).\n\n`data` will be either a `String` or a `Buffer/Uint8Array` (see [buffer](https://github.com/feross/buffer)).\n\n### `peer.on('stream', function (stream) {})`\n\nReceived a remote video stream, which can be displayed in a video tag:\n\n```js\npeer.on('stream', function (stream) {\n  var video = document.createElement('video')\n  video.src = window.URL.createObjectURL(stream)\n  document.body.appendChild(video)\n  video.play()\n})\n```\n\n### `peer.on('close', function () {})`\n\nCalled when the peer connection has closed.\n\n### `peer.on('error', function (err) {})`\n\nFired when a fatal error occurs. Usually, this means bad signaling data was received from the remote peer.\n\n`err` is an `Error` object.\n\n## license\n\nMIT. Copyright (c) [Feross Aboukhadijeh](http://feross.org).\n",
  "readmeFilename": "README.md",
  "_id": "simple-peer@3.6.4",
  "_from": "simple-peer@^3.2.0"
}
