{
  "name": "castv2",
  "version": "0.1.4",
  "description": "An implementation of the Chromecast CASTV2 protocol",
  "author": {
    "name": "thibauts"
  },
  "license": "MIT",
  "main": "index.js",
  "dependencies": {
    "debug": "~0.8.1",
    "protobufjs": "^3.2.2"
  },
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/thibauts/node-castv2.git"
  },
  "keywords": [
    "chromecast",
    "castv2"
  ],
  "readme": "castv2\r\n======\r\n### An implementation of the Chromecast CASTV2 protocol\r\n\r\nThis module is an implementation of the Chromecast CASTV2 protocol over TLS. The internet is very scarse on information about the new Chromecast protocol so big props go to [github.com/vincentbernat](https://github.com/vincentbernat) and his [nodecastor](https://github.com/vincentbernat/nodecastor) module that helped me start off on the right foot and save a good deal of time in my research.\r\n\r\nThe module provides both a `Client` and a `Server` implementation of the low-level protocol. The server is (sadly) pretty useless because device authentication gets in the way for now (and maybe for good). The client still allows you to connect and exchange messages with a Chromecast dongle without any restriction. \r\n\r\nInstallation\r\n------------\r\n\r\n``` bash\r\n$ npm install castv2\r\n```\r\n\r\nOn windows, to avoid native modules dependencies, use\r\n\r\n``` bash\r\n$ npm install castv2 --no-optional\r\n```\r\n\r\nUsage\r\n-----\r\n\r\n``` javascript\r\nvar Client = require('castv2').Client;\r\nvar mdns = require('mdns');\r\n\r\nvar browser = mdns.createBrowser(mdns.tcp('googlecast'));\r\n\r\nbrowser.on('serviceUp', function(service) {\r\n  console.log('found device %s at %s:%d', service.name, service.addresses[0], service.port);\r\n  ondeviceup(service.addresses[0]);\r\n  browser.stop();\r\n});\r\n\r\nbrowser.start();\r\n\r\nfunction ondeviceup(host) {\r\n\r\n  var client = new Client();\r\n  client.connect(host, function() {\r\n    // create various namespace handlers\r\n    var connection = client.createChannel('sender-0', 'receiver-0', 'urn:x-cast:com.google.cast.tp.connection', 'JSON');\r\n    var heartbeat  = client.createChannel('sender-0', 'receiver-0', 'urn:x-cast:com.google.cast.tp.heartbeat', 'JSON');\r\n    var receiver   = client.createChannel('sender-0', 'receiver-0', 'urn:x-cast:com.google.cast.receiver', 'JSON');\r\n\r\n    // establish virtual connection to the receiver\r\n    connection.send({ type: 'CONNECT' });\r\n\r\n    // start heartbeating\r\n    setInterval(function() {\r\n      heartbeat.send({ type: 'PING' });\r\n    }, 5000);\r\n\r\n    // launch YouTube app\r\n    receiver.send({ type: 'LAUNCH', appId: 'YouTube', requestId: 1 });\r\n\r\n    // display receiver status updates\r\n    receiver.on('message', function(data, broadcast) {\r\n      if(data.type = 'RECEIVER_STATUS') {\r\n        console.log(data.status);\r\n      }\r\n    });\r\n  });\r\n\r\n}\r\n```\r\n\r\nRun it with the following command to get a full trace of the messages exchanged with the dongle.\r\n\r\n```bash \r\n$ DEBUG=* node example.js\r\n```\r\n\r\nProtocol description\r\n--------------------\r\n\r\nThis is an attempt at documenting the low-level protocol. I hope it will give sender-app makers a clearer picture of what is happening behind the curtain, and give the others ideas about how this kind of protocol can be implemented. The information presented here has been collated from various internet sources (mainly exemple code and other attempts to implement the protocol) and my own trial and error. Correct me as needed as I may have gotten concepts or namings wrong.\r\n\r\n### The TLS / Protocol Buffers layer\r\n\r\nThe client connects to the Chromecast through TLS on port 8009. Once the connection is established server and client exchange length-prefixed binary messages (that we'll call packets).\r\n\r\nPackets have the following structure :\r\n\r\n```\r\n+----------------+------------------------------------------------+\r\n| Packet length  |               Payload (message)                |\r\n+----------------+------------------------------------------------+\r\n```\r\n\r\nPacket length is a 32 bits Big Endian Unsigned Integer (UInt32BE in nodejs parlance) that determines the payload size.\r\n\r\nMessages are serialized with Protocol Buffers and structured as follows (excerpt of `cast_channel.proto` with comments stripped) :\r\n\r\n```protobuf\r\nmessage CastMessage {\r\n  enum ProtocolVersion {\r\n    CASTV2_1_0 = 0;\r\n  }\r\n  required ProtocolVersion protocol_version = 1;\r\n\r\n  required string source_id = 2;\r\n  required string destination_id = 3;\r\n\r\n  required string namespace = 4;\r\n\r\n  enum PayloadType {\r\n    STRING = 0;\r\n    BINARY = 1;\r\n  }\r\n  required PayloadType payload_type = 5;\r\n\r\n  optional string payload_utf8 = 6;\r\n  optional bytes payload_binary = 7;\r\n}\r\n\r\n```\r\n\r\nThe original .proto file can also be found in the Chromium source tree.\r\n\r\nUsing this structure the sender and receiver *platforms* (eg. The Chrome browser and the Chromecast device) as well as sender and receiver *applications* (eg. a Chromecast receiver app and a Chrome browser sender app for YouTube) communicate on *channels*.\r\n\r\nSenders and receivers identify themselves through IDs : `source_id` and `destination_id`. The sending platform (eg. the Chrome browser) usually uses `sender-0`. The receiving platform (the Chromecast dongle) uses `receiver-0`. Other senders and receivers use identifiers such as `sender-sdqo7ozi6s4a`, `client-4637` or `web-4`. We'll dig into that later.\r\n\r\n### Namespaces\r\n\r\nSenders and receivers communicate through *channels* defined by the `namespace` field. Each namespace corresponds to a protocol that can have its own semantics. Protocol-specific data is carried in the `payload_utf8` or `payload_binary` fields. Either one or the other is present in the message depending on the `payload_type` field value. Thanks to that, applications can define their own protocols and transparently exchange arbitrary data, including binary data, alleviating the need to establish additional connections (ie. websockets).\r\n\r\nThough, many protocols use JSON encoded messages / commands, which makes them easy to understand and implement.\r\n\r\nEach *sender* or *receiver* can implement one or multiple protocols. For instance the Chromecast *platform* (`receiver-0`) implements the protocols for the following namespaces : `urn:x-cast:com.google.cast.tp.connection`, `urn:x-cast:com.google.cast.tp.heartbeat`, `urn:x-cast:com.google.cast.receiver` and `urn:x-cast:com.google.cast.tp.deviceauth`.\r\n\r\n### Communicating with receivers\r\n\r\nBefore being able to echange messages with a receiver (be it an *application* or the *platform*), a sender must establish a *virtual connection* with it. This is accomplished through the `urn:x-cast:com.google.cast.tp.connection` namespace / protocol. This has the effect of both allowing the sender to send messages to the receiver, and of subscribing the sender to the receiver's broadcasts (eg. status updates).\r\n\r\nThe protocol is JSON encoded and the semantics are pretty simple :\r\n\r\n| **Message payload**     | **Description** \r\n|:------------------------|:-----------------------------------------------------------------------\r\n| `{ \"type\": \"CONNECT\" }` | establishes a virtual connection between the sender and the receiver \r\n| `{ \"type\": \"CLOSE\" }`   | closes a virtual connection \r\n\r\nThe sender may receive a `CLOSE` message from the receiver that terminates the virtual connection. This sometimes happens in error cases.\r\n\r\nOnce the virtual connection is established messages can be exchanged. Broadcasts from the receiver will have a `*` value for the `destination_id` field.\r\n\r\n### Keeping the connection alive\r\n\r\nConnections are kept alive through the `urn:x-cast:com.google.cast.tp.heartbeat` namespace / protocol. At regular intervals the sender must send a `PING` message that will get answered by a `PONG`. The protocol is JSON encoded.\r\n\r\n| **Message payload**     | **Description** \r\n|:------------------------|:-----------------------------------------------------------------------\r\n| `{ \"type\": \"PING\" }`    | notifies the other end that we are sill alive\r\n| `{ \"type\": \"PONG\" }`    | the other end acknowledges that we are\r\n\r\nFailing to do so will lead to connection termination. The default interval seems to be 5 seconds. This protocol allows the Chromecast to detect unresponsive / offline senders much quicker than the TCP keepalive mechanism.\r\n\r\n### Device authentication\r\n\r\nDevice authentication enables a sender to authenticate a Chromecast device. Authenticating the device is purely optional from a sender's perspective, though the official SDK libraries do it to prevent rogue Chromecast devices to communicate with the official sender platforms. Device authentication is taken care of by the `urn:x-cast:com.google.cast.tp.deviceauth` namespace / protocol.\r\n\r\nFirst the sender sends a *challenge* message to the platform receiver `receiver-0` which responds by either a *response* message containing a signature and a certificate or an *error* message. These 3 payloads are protocol buffers encoded and described in `cast_channel.proto` as follows :\r\n\r\n```protobuf\r\nmessage AuthChallenge {\r\n}\r\n\r\nmessage AuthResponse {\r\n  required bytes signature = 1;\r\n  required bytes client_auth_certificate = 2;\r\n}\r\n\r\nmessage AuthError {\r\n  enum ErrorType {\r\n    INTERNAL_ERROR = 0;\r\n    NO_TLS = 1;  // The underlying connection is not TLS\r\n  }\r\n  required ErrorType error_type = 1;\r\n}\r\n\r\nmessage DeviceAuthMessage {\r\n  optional AuthChallenge challenge = 1;\r\n  optional AuthResponse response = 2;\r\n  optional AuthError error = 3;\r\n}\r\n```\r\n\r\nThe challenge message is empty in the current version of the protocol (CAST v2.1.0), yet official sender platforms are checking the returned certificate and signature. Details of the verification process can be found in [this issue](https://github.com/thibauts/node-castv2-messagebus/issues/2).\r\n\r\n### Controlling applications\r\n\r\nThe platform receiver `receiver-0` implements the `urn:x-cast:com.google.cast.receiver` namespace / protocol which provides an interface to *launch*, *stop*, and *query the status* of running applications. `receiver-0` also broadcast status messages on this namespace when other senders launch, stop, or affect the status of running apps. It also allows to check app for availability.\r\n\r\nThe protocol is JSON encoded and is request / response based. Requests include a `type` field containing the type of the request, namely `LAUNCH`, `STOP`, `GET_STATUS` and `GET_APP_AVAILABILITY`, and a `requestId` field that will be reflected in the receiver's response and allows the sender to pair request and responses. `requestId` is not shown in the table below but must be present in every request. In the wild it is an initially random integer that gets incremented for each subsequent request.\r\n\r\n| **Message payload**                                  | **Description** \r\n|:-----------------------------------------------------|:-----------------------------------------------------------------------\r\n| `{ \"type\": \"LAUNCH\", appId: <string> }`              | launches an application\r\n| `{ \"type\": \"STOP\", sessionId: <string> }`            | stops a running instance of an application\r\n| `{ \"type\": \"GET_STATUS\" }`                           | returns the status of the platform receiver, including details about running apps.\r\n| `{ \"type\": \"GET_APP_AVAILABILITY\", appId: <array> }` | returns availability of requested apps. `appId` is an array of application IDs.\r\n\r\n`appId` may be eg. `YouTube` or `CC1AD845` for the *Default Media Receiver* app. A `sessionId` identifies a running instance of an application and is provided in status messages.\r\n\r\nAs these requests affect the receiver's status they all return a `RECEIVER_STATUS` message of the following form :\r\n\r\n```json\r\n{\r\n  \"requestId\": 8476438,\r\n  \"status\": { \r\n    \"applications\": [\r\n      { \"appId\": \"CC1AD845\",\r\n        \"displayName\": \"Default Media Receiver\",\r\n        \"namespaces\": [ \r\n          \"urn:x-cast:com.google.cast.player.message\",\r\n          \"urn:x-cast:com.google.cast.media\"\r\n        ],\r\n        \"sessionId\": \"7E2FF513-CDF6-9A91-2B28-3E3DE7BAC174\",\r\n        \"statusText\": \"Ready To Cast\",\r\n        \"transportId\":  \"web-5\" }\r\n    ],\r\n    \"isActiveInput\": true,\r\n    \"volume\": { \r\n      \"level\": 1,\r\n      \"muted\": false \r\n    }\r\n  },\r\n  \"type\": \"RECEIVER_STATUS\"\r\n}\r\n```\r\n\r\nThis response indicates an instance of the *Default Media Receiver* is running with `sessionId 7E2FF513-CDF6-9A91-2B28-3E3DE7BAC174`. `namespaces` indicates which protocols are supported by the running app. This could allow any *sender application* implementing the *media protocol* to control playback on this session.\r\n\r\nAnother important field here is `transportId` as it is the destinationId to be used to communicate with the app. Note that the app being a receiver like any other you must issue it a `CONNECT` message through the `urn:x-cast:com.google.cast.tp.connection` procotol before being able to send messages. In this case this will have the side effect of subscribing you to media updates (on the media channel) of this *Default Media Player* session.\r\n\r\nYou can join an existing session (launched by another sender) by issuing the same `CONNECT` message.\r\n\r\n### Controlling device volume\r\n\r\n`receiver-0` allows setting volume and muting at the device-level through the `SET_VOLUME` request on `urn:x-cast:com.google.cast.receiver`.\r\n\r\n| **Message payload**                                        | **Description** \r\n|:-----------------------------------------------------------|:-----------------------------------------------------------\r\n| `{ \"type\": \"SET_VOLUME\", \"volume\": { level: <float> } }`   | sets volume. `level` is a float between 0 and 1\r\n| `{ \"type\": \"SET_VOLUME\", \"volume\": { muted: <boolean> } }` | mutes / unmutes. `muted` is true or false\r\n\r\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/thibauts/node-castv2/issues"
  },
  "homepage": "https://github.com/thibauts/node-castv2",
  "_id": "castv2@0.1.4",
  "_from": "castv2@~0.1.4"
}
